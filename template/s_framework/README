Proof of concept for a framework loader

Criteria:

* Should be possible to load the framework easily for app developers
* Should be possible to centrally upgrade the framework for all applications
* Should not require network access
* Should load jQuery Mobile plus any extensions
* Should support multiple framework versions
* Should support multiple themes

What a developer needs to do in their application:

(I should mention that this is kind of ripped off from how Enyo does
things on webOS. I haven't used any Enyo code, however.)

* Application developer drops a single bootstrap.js file into their
  application. This contains a basic loader script, plus defaults for
  the framework and theme to be used. It also contains inlined versions
  of domready.js (for DOM ready checking) and LAB.js (for async script
  loading). (Both are MIT licensed.)

* In index.html, they add a script tag to load bootstrap.js
  and specify parameters for the loader. For example:

  <script src="bootstrap.js"
          data-framework-version="2.0"
          data-framework-root="s_framework"
          data-framework-theme="slp">
  </script>

* They create a config.js file to specify which of their own JS files
  need to be loaded, other app config etc. For example:

  S.load(
    'app/file1.js',
    'app/file2.js',
    'app/main.js'
  );

  Note that as config.js is loaded last, it can reference any framework
  functions. In this case, 'S' is an arbitrary namespace I picked for
  our framework; the load() function is defined in bootstrap.js, and
  simply loads the specified JS files (relative to the application root
  directory) in order.

The framework:

* This is installed as a standard Linux package, e.g. into /usr/local/share

* The package contains every version of the framework, plus every theme
  applicable to each version (these could be split into separate "code"
  and "theme" packages, maybe)

* For each version, we put all the JS files (jQuery, jQuery Mobile,
  jQuery extensions, utilities)

What happens when the app loads:

* bootstrap.js is loaded

* The auto-run function in bootstrap.js is called once the DOM is ready.
  This does the following:

  - Hides the <body> element until everything is loaded

  - Sets a default root location for the framework files (s_framework in
    this demo, but could be an absolute file:// path)

  - Sets a default version of the framework to load (1.0)

  - Sets a default theme to load (default)

  - Finds the bootstrap.js <script> element in the DOM

  - Replaces any of the defaults (root, version, theme) with values
    from data- attributes on the <script> element; available values
    are:
      * root = <relative or absolute URI>
      * version = 1.0 or 2.0 (actually the same jQuery Mobile version)
      * theme = default or slp (the latter just has a
        different header/footer colour)

  - Appends a <link rel="stylesheet"...> element to the head to
    load the theme's stylesheet

  - Uses LAB.js to load the framework JS files (in this demo, jQuery,
    jQuery Mobile, Underscore.js; for the real framework, it would also
    include our extensions/libraries); the names of the files are
    specified in bootstrap.js

  - Loads config.js: any code in it runs, which may include
    loading more JavaScript files (via S.load() for example); one of
    the loaded files should do the actual application stuff (equivalent of
    a main() function). This could even be done in config.js, but that's
    probably not good (perhaps it should be called app.js?).

    Alternatively, the framework could be given the
    name of a function to run when everything is loaded; or S.load() could
    be passed a callback to run when all the specified files are loaded;
    etc. (I've left this open for now).

    In this demo file1.js and file2.js contain a single function each,
    and main.js calls them both to set some DOM elements, just to
    demonstrate that they have been loaded.

  - Shows the <body> element once config.js has finished loading; NB this
    may be before the developer's own scripts have loaded (if loaded via
    S.load()).

Pros:

* A developer has to add two JS files (config.js and bootstrap.js) plus
  one <script> element to their application to use the framework.

* The framework can be updated in one place on the system.

* The framework is available from the local filesystem (no network access).

Cons:

* We might need to update bootstrap.js: because this is dropped into the
  application, it requires a manual update by the developer if it changes.
  We need to keep it as simple as possible so it doesn't need to be updated
  too often, and remains backwards-compatible with previous versions of
  config.js.

  The version here is what I'd consider the minimal useful version, but
  there's lots of scope to add/remove code.

  We could add functionality: for example, if we had optional parts of
  the framework, we could perhaps use another data-framework-modules
  attribute to specify optional modules to load. But this would make
  bootstrap.js more complex and harder to maintain.

  We could remove code to simplify, but potentially make bootstrap.js less
  intuitive and useful. For example, I have some error checking code to
  ensure that the specified theme and framework version are available:
  we could remove this to simplify things, at the expense of worse
  feedback to developers if the framework fails to load (their app
  basically breaks everywhere).

* We need to enumerate all the framework JS files which should be loaded
  in bootstrap.js. However, we could make this list as small as possible
  by minifying our JS into a single file (though this might increase
  load times) or a small number of minified files with constant names.

  Something like sprockets (http://getsprockets.org/) might be a
  path to packing our scripts into one file; or we could just
  concatenate them and minimise them with the YUI compressor
  (http://developer.yahoo.com/yui/compressor/) or similar.
